{"version":3,"file":"bundle-main.js","mappings":"AAGA","sources":["webpack:///./js/menu-plugin/SlideMenu.js","webpack:///./js/menu-plugin/utils/dom.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./js/main.js"],"sourcesContent":[" \"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst dom_1 = require(\"./utils/dom\");\n\nlet Direction;\n(function (Direction) {\n  Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n  Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n})(Direction || (Direction = {}));\n\nlet MenuPosition;\n(function (MenuPosition) {\n  MenuPosition[\"Left\"] = \"left\";\n  MenuPosition[\"Right\"] = \"right\";\n})(MenuPosition || (MenuPosition = {}));\n\nlet Action;\n(function (Action) {\n  Action[\"Back\"] = \"back\";\n  Action[\"Close\"] = \"close\";\n  Action[\"Forward\"] = \"forward\";\n  Action[\"Navigate\"] = \"navigate\";\n  Action[\"Open\"] = \"open\";\n})(Action || (Action = {}));\n\nlet DEFAULT_OPTIONS = {\n  backLinkAfter: '',\n  backLinkBefore: '<span class=\"prew-default-double-arrows\"> Back </span>',\n  keyClose: '',\n  keyOpen: '',\n  position: 'right',\n  showBackLink: true,\n  showTitle: true,\n  submenuLinkAfter: '<span class=\"next-default-arrow\"></span>',\n  submenuLinkBefore: '',\n  slideContent: '',\n  saveMenuState: true,\n};\n\nlet SlideMenu = (function () {\n  function SlideMenu(elem, options) {\n    this.level = 0;\n    this.isOpen = false;\n    this.isAnimating = false;\n    this.lastAction = null;\n    if (elem === null) {\n      throw new Error('Argument `elem` must be a valid HTML node');\n    }\n    // (Create a new object for every instance)\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.menuElem = elem;\n    // Add wrapper (for the slide effect)\n    this.wrapperElem = document.createElement('div');\n    this.wrapperElem.classList.add(SlideMenu.CLASS_NAMES.wrapper);\n    const firstUl = this.menuElem.querySelector('ul');\n    if (firstUl) {\n      dom_1.wrapElement(firstUl, this.wrapperElem);\n    }\n    this.initMenu();\n    this.initSubmenus();\n    this.initEventHandlers();\n    // Save this instance in menu DOM node\n    this.menuElem._slideMenu = this;\n  }\n  /**\n   * Toggle the menu\n   */\n  SlideMenu.prototype.toggle = function (show, animate) {\n    if (animate === void 0) { animate = true; }\n    let offset;\n    const leftPosition = this.options.position === MenuPosition.Left;\n    const slideContentClass = leftPosition ? SlideMenu.CLASS_NAMES.slideContentLeft : SlideMenu.CLASS_NAMES.slideContentRight;\n    const translateContentValue = leftPosition ? this.menuElem.offsetWidth + 'px' : - this.menuElem.offsetWidth + 'px';\n\n    if (show === undefined) {\n      return this.isOpen ? this.close(animate) : this.open(animate);\n    }\n    else if (show) {\n      offset = 0;\n      if (this.options.slideContent) {\n        document.getElementsByClassName(this.options.slideContent)[0].classList.add(slideContentClass);\n        document.getElementsByClassName(this.options.slideContent)[0].style.transform = `translateX(${translateContentValue})`;\n      }\n    }\n    else {\n      offset = this.options.position === MenuPosition.Left ? '-100%' : '100%';\n      if (this.options.slideContent) {\n        document.getElementsByClassName(this.options.slideContent)[0].classList.remove(slideContentClass);\n        document.getElementsByClassName(this.options.slideContent)[0].style.transform = `translateX(0)`;\n      }\n    }\n    this.isOpen = show;\n    if (animate) {\n      this.moveSlider(this.menuElem, offset);\n    }\n    else {\n      let action = this.moveSlider.bind(this, this.menuElem, offset);\n      this.runWithoutAnimation(action);\n    }\n  };\n  /**\n   * Open the menu\n   */\n  SlideMenu.prototype.open = function (animate) {\n    if (animate === void 0) { animate = true; }\n    this.triggerEvent(Action.Open);\n    this.toggle(true, animate);\n    document.getElementsByTagName( 'html' )[0].classList.add('slide-menu-opened' );\n  };\n  /**\n   * Close the menu\n   */\n  SlideMenu.prototype.close = function (animate) {\n    if (animate === void 0) { animate = true; }\n    this.triggerEvent(Action.Close);\n    this.toggle(false, animate);\n    if(this.options.saveMenuState === false) {\n      this.navigateTo(`.${SlideMenu.CLASS_NAMES.listItem}`);\n    }\n    document.getElementsByTagName( 'html' )[0].classList.remove('slide-menu-opened');\n  };\n  /**\n   * Navigate one menu hierarchy back if possible\n   */\n  SlideMenu.prototype.back = function () {\n    // Event is triggered in navigate()\n    this.navigate(Direction.Backward);\n  };\n  /**\n   * Destroy the SlideMenu\n   */\n  SlideMenu.prototype.destroy = function () {\n    var _a = this.options, submenuLinkAfter = _a.submenuLinkAfter, submenuLinkBefore = _a.submenuLinkBefore, showBackLink = _a.showBackLink;\n    // Remove link decorators\n    if (submenuLinkAfter || submenuLinkBefore) {\n      var linkDecorators = Array.from(this.wrapperElem.querySelectorAll(\".\" + SlideMenu.CLASS_NAMES.decorator));\n      linkDecorators.forEach(function (decorator) {\n        if (decorator.parentElement) {\n          decorator.parentElement.removeChild(decorator);\n        }\n      });\n    }\n    // Remove back links\n    if (showBackLink) {\n      var backLinks = Array.from(this.wrapperElem.querySelectorAll(\".\" + SlideMenu.CLASS_NAMES.control));\n      backLinks.forEach(function (backlink) {\n        var parentLi = dom_1.parentsOne(backlink, 'li');\n        if (parentLi && parentLi.parentElement) {\n          parentLi.parentElement.removeChild(parentLi);\n        }\n      });\n    }\n    // Remove the wrapper element\n    dom_1.unwrapElement(this.wrapperElem);\n    // Remove inline styles\n    this.menuElem.style.cssText = '';\n    this.menuElem.querySelectorAll('ul').forEach(function (ul) { return (ul.style.cssText = ''); });\n    // Delete the reference to *this* instance\n    // NOTE: Garbage collection is not possible, as long as other references to this object exist\n    delete this.menuElem._slideMenu;\n  };\n  /**\n   * Navigate to a specific link on any level (useful to open the correct hierarchy directly)\n   */\n  SlideMenu.prototype.navigateTo = function (target) {\n    this.triggerEvent(Action.Navigate);\n    if (typeof target === 'string') {\n      var elem = document.querySelector(target);\n      if (elem instanceof HTMLElement) {\n        target = elem;\n      }\n      else {\n        throw new Error('Invalid parameter `target`. A valid query selector is required.');\n      }\n    }\n    // Hide other active menus\n    var activeMenus = Array.from(this.wrapperElem.querySelectorAll(\".\" + SlideMenu.CLASS_NAMES.active));\n    activeMenus.forEach(function (activeElem) {\n      activeElem.style.display = 'none';\n      activeElem.classList.remove(SlideMenu.CLASS_NAMES.active);\n    });\n    var parentUl = dom_1.parents(target, 'ul');\n    var level = parentUl.length - 1;\n    // Trigger the animation only if currently on different level\n    if (level >= 0 && level !== this.level) {\n      this.level = level;\n      this.moveSlider(this.wrapperElem, -this.level * 100);\n    }\n    parentUl.forEach(function (ul) {\n      ul.style.display = 'block';\n      ul.classList.add(SlideMenu.CLASS_NAMES.active);\n    });\n  };\n  /**\n   * Set up all event handlers\n   */\n  SlideMenu.prototype.initEventHandlers = function () {\n    const _this = this;\n    // Ordinary links inside the menu\n    const anchors = Array.from(this.menuElem.querySelectorAll('a'));\n    anchors.forEach(function (anchor) {\n      return anchor.addEventListener('click', function (event) {\n        const target = event.target;\n        let targetAnchor = target.matches('a') ? target : dom_1.parentsOne(target, 'a');\n        let targetCurrent = target.matches('span') ? target : null;\n        if (targetCurrent) {\n          _this.navigate(Direction.Forward, targetAnchor);\n        }\n      });\n    });\n    // Handler for end of CSS transition\n    this.menuElem.addEventListener('transitionend', this.onTransitionEnd.bind(this));\n    this.wrapperElem.addEventListener('transitionend', this.onTransitionEnd.bind(this));\n    this.initKeybindings();\n    this.initSubmenuVisibility();\n  };\n  SlideMenu.prototype.onTransitionEnd = function (event) {\n    // Ensure the transitionEnd event was fired by the correct element\n    // (elements inside the menu might use CSS transitions as well)\n    if (event.target !== this.menuElem && event.target !== this.wrapperElem) {\n      return;\n    }\n    this.isAnimating = false;\n    if (this.lastAction) {\n      this.triggerEvent(this.lastAction, true);\n      this.lastAction = null;\n    }\n  };\n  SlideMenu.prototype.initKeybindings = function () {\n    const _this = this;\n    document.addEventListener('keydown', function (event) {\n      switch (event.key) {\n        case _this.options.keyClose:\n          _this.close();\n          break;\n        case _this.options.keyOpen:\n          _this.open();\n          break;\n        default:\n          return;\n      }\n      event.preventDefault();\n    });\n  };\n  SlideMenu.prototype.initSubmenuVisibility = function () {\n    const _this = this;\n    // Hide the lastly shown menu when navigating back (important for navigateTo)\n    this.menuElem.addEventListener('sm.back-after', function () {\n      var lastActiveSelector = (\".\" + SlideMenu.CLASS_NAMES.active + \" \").repeat(_this.level + 1);\n      var lastActiveUl = _this.menuElem.querySelector(\"ul \" + lastActiveSelector);\n      if (lastActiveUl) {\n        lastActiveUl.style.display = 'none';\n        lastActiveUl.classList.remove(SlideMenu.CLASS_NAMES.active);\n      }\n    });\n  };\n  /**\n   * Trigger a custom event to support callbacks\n   */\n  SlideMenu.prototype.triggerEvent = function (action, afterAnimation) {\n    if (afterAnimation === void 0) { afterAnimation = false; }\n    this.lastAction = action;\n    let name = \"sm.\" + action + (afterAnimation ? '-after' : '');\n    let event = new CustomEvent(name);\n    this.menuElem.dispatchEvent(event);\n  };\n  /**\n   * Navigate the menu - that is slide it one step left or right\n   */\n  SlideMenu.prototype.navigate = function (dir, anchor) {\n    if (dir === void 0) { dir = Direction.Forward; }\n    if (this.isAnimating || (dir === Direction.Backward && this.level === 0)) {\n      return;\n    }\n    let offset = (this.level + dir) * -100;\n    if (anchor && anchor.parentElement !== null && dir === Direction.Forward) {\n      let ul = anchor.parentElement.querySelector('ul');\n      if (!ul) {\n        return;\n      }\n      ul.classList.add(SlideMenu.CLASS_NAMES.active);\n      ul.style.display = 'block';\n    }\n    let action = dir === Direction.Forward ? Action.Forward : Action.Back;\n    this.triggerEvent(action);\n    this.level = this.level + dir;\n    this.moveSlider(this.wrapperElem, offset);\n  };\n  /**\n   * Start the slide animation (the CSS transition)\n   */\n  SlideMenu.prototype.moveSlider = function (elem, offset) {\n    // Add percentage sign\n    if (!offset.toString().includes('%')) {\n      offset += '%';\n    }\n    elem.style.transform = \"translateX(\" + offset + \")\";\n    this.isAnimating = true;\n  };\n  /**\n   * Initialize the menu\n   */\n  SlideMenu.prototype.initMenu = function () {\n    let _this = this;\n    this.runWithoutAnimation(function () {\n      switch (_this.options.position) {\n        case MenuPosition.Left:\n          Object.assign(_this.menuElem.style, {\n            left: 0,\n            right: 'auto',\n            transform: 'translateX(-100%)',\n          });\n          break;\n        default:\n          Object.assign(_this.menuElem.style, {\n            left: 'auto',\n            right: 0,\n          });\n          break;\n      }\n      _this.menuElem.style.display = 'block';\n    });\n  };\n  /**\n   * Pause the CSS transitions, to apply CSS changes directly without an animation\n   */\n  SlideMenu.prototype.runWithoutAnimation = function (action) {\n    var transitionElems = [this.menuElem, this.wrapperElem];\n    transitionElems.forEach(function (elem) { return (elem.style.transition = 'none'); });\n    action();\n    this.menuElem.offsetHeight; // Trigger a reflow, flushing the CSS changes\n    transitionElems.forEach(function (elem) { return elem.style.removeProperty('transition'); });\n    this.isAnimating = false;\n  };\n  /**\n   * Enhance the markup of menu items which contain a submenu\n   */\n  SlideMenu.prototype.initSubmenus = function () {\n    var _this = this;\n    this.menuElem.querySelectorAll('a').forEach(function (anchor) {\n      if (anchor.parentElement === null) {\n        return;\n      }\n      var submenu = anchor.parentElement.querySelector('ul');\n      if (!submenu) {\n        return;\n      }\n\n      let backLinkTitle = anchor.parentElement.parentElement.parentElement.getElementsByClassName(SlideMenu.CLASS_NAMES.title).length ? (anchor.parentElement.parentElement.parentElement.getElementsByClassName(SlideMenu.CLASS_NAMES.title)[0].textContent) : '';\n\n      // Prevent default behaviour (use link just to navigate)\n      anchor.addEventListener('click', function (event) {\n         event.preventDefault();\n      });\n      var anchorText = anchor.textContent;\n      _this.addLinkDecorators(anchor);\n      // Add Title\n      if (_this.options.showTitle) {\n        var _t = _this.options;\n        var title = document.createElement('a');\n        title.innerHTML = anchorText;\n        title.classList.add(SlideMenu.CLASS_NAMES.title);\n        var titleLi = document.createElement('li');\n        titleLi.appendChild(title);\n        titleLi.classList.add(SlideMenu.CLASS_NAMES.listItem);\n        submenu.insertBefore(titleLi, submenu.firstChild);\n      }\n      // Add back links\n      if (_this.options.showBackLink) {\n        var _a = _this.options, backLinkBefore = _a.backLinkBefore, backLinkAfter = _a.backLinkAfter;\n        var backLink = document.createElement('a');\n        backLink.innerHTML = backLinkBefore + backLinkTitle + backLinkAfter;\n        backLink.classList.add(SlideMenu.CLASS_NAMES.backlink, SlideMenu.CLASS_NAMES.control);\n        backLink.setAttribute('data-action', Action.Back);\n        var backLinkLi = document.createElement('li');\n        backLinkLi.appendChild(backLink);\n        backLinkLi.classList.add(SlideMenu.CLASS_NAMES.listItem);\n        submenu.insertBefore(backLinkLi, submenu.firstChild);\n      }\n    });\n  };\n  // Add `before` and `after` text\n  SlideMenu.prototype.addLinkDecorators = function (anchor) {\n    var _a = this.options, submenuLinkBefore = _a.submenuLinkBefore, submenuLinkAfter = _a.submenuLinkAfter;\n    if (submenuLinkBefore) {\n      var linkBeforeElem = document.createElement('span');\n      linkBeforeElem.classList.add(SlideMenu.CLASS_NAMES.decorator);\n      linkBeforeElem.innerHTML = submenuLinkBefore;\n      anchor.insertBefore(linkBeforeElem, anchor.firstChild);\n    }\n    if (submenuLinkAfter) {\n      var linkAfterElem = document.createElement('span');\n      linkAfterElem.classList.add(SlideMenu.CLASS_NAMES.decorator);\n      linkAfterElem.innerHTML = submenuLinkAfter;\n      anchor.appendChild(linkAfterElem);\n    }\n    return anchor;\n  };\n\n  SlideMenu.NAMESPACE = 'slide-menu';\n  SlideMenu.CLASS_NAMES = {\n    active: SlideMenu.NAMESPACE + \"__submenu--active\",\n    backlink: SlideMenu.NAMESPACE + \"__backlink\",\n    control: SlideMenu.NAMESPACE + \"__control\",\n    decorator: SlideMenu.NAMESPACE + \"__decorator\",\n    wrapper: SlideMenu.NAMESPACE + \"__slider\",\n    title: SlideMenu.NAMESPACE + \"__title\",\n    listItem: SlideMenu.NAMESPACE + \"__list-item\",\n    slideContentRight: SlideMenu.NAMESPACE + \"__right-menu-active\",\n    slideContentLeft: SlideMenu.NAMESPACE + \"__left-menu-active\",\n  };\n  return SlideMenu;\n}());\n\n// Link control buttons with the API\ndocument.addEventListener('click', function (event) {\n  if (!(event.target instanceof HTMLElement)) {\n    return;\n  }\n  let btn = event.target.className.includes(SlideMenu.CLASS_NAMES.control)\n      ? event.target\n      : dom_1.parentsOne(event.target, \".\" + SlideMenu.CLASS_NAMES.control);\n  if (!btn || !btn.className.includes(SlideMenu.CLASS_NAMES.control)) {\n    return;\n  }\n  const target = btn.getAttribute('data-target');\n  let menu = !target || target === 'this'\n      ? dom_1.parentsOne(btn, \".\" + SlideMenu.NAMESPACE)\n      : document.getElementById(target); // assumes #id\n  if (!menu) {\n    throw new Error(\"Unable to find menu \" + target);\n  }\n  const instance = menu._slideMenu;\n  const method = btn.getAttribute('data-action');\n  const arg = btn.getAttribute('data-arg');\n  if (instance && method && typeof instance[method] === 'function') {\n    arg ? instance[method](arg) : instance[method]();\n  }\n});\n\n// Expose SlideMenu to the global namespace\nwindow.SlideMenu = SlideMenu;\n","export const wrapElement = (elem, wrapper) => {\n  if (elem.parentElement === null) {\n    throw Error('`elem` has no parentElement');\n  }\n  elem.parentElement.insertBefore(wrapper, elem);\n  wrapper.appendChild(elem);\n  return elem;\n}\n\n\nexport const unwrapElement = (elem) => {\n  let parent = elem.parentElement;\n  if (parent === null) {\n    throw Error('`elem` has no parentElement');\n  }\n  while (elem.firstChild) {\n    parent.insertBefore(elem.firstChild, elem);\n  }\n  parent.removeChild(elem);\n}\n\nexport const parents = (elem, selector, limit) => {\n  let matched = [];\n  while (elem &&\n  elem.parentElement !== null &&\n  (limit === undefined ? true : matched.length < limit)) {\n    if (elem instanceof HTMLElement && elem.matches(selector)) {\n      matched.push(elem);\n    }\n    elem = elem.parentElement;\n  }\n  return matched;\n}\n\nexport const parentsOne = (elem, selector) => {\n  const matches = parents(elem, selector, 1);\n  return matches.length ? matches[0] : null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './menu-plugin/SlideMenu.js';\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const menuElement = document.getElementById('slide-menu');\n  const menu = new SlideMenu(menuElement, {\n    'slideContent': 'main-container',\n    'saveMenuState' : false,\n    'backLinkBefore': 'zurück',\n  });\n});\n\n"],"names":["Direction","MenuPosition","Action","dom_1","require","DEFAULT_OPTIONS","backLinkAfter","backLinkBefore","keyClose","keyOpen","position","showBackLink","showTitle","submenuLinkAfter","submenuLinkBefore","slideContent","saveMenuState","SlideMenu","elem","options","this","level","isOpen","isAnimating","lastAction","Error","Object","assign","menuElem","wrapperElem","document","createElement","classList","add","CLASS_NAMES","wrapper","firstUl","querySelector","wrapElement","initMenu","initSubmenus","initEventHandlers","_slideMenu","prototype","toggle","show","animate","offset","leftPosition","Left","slideContentClass","slideContentLeft","slideContentRight","translateContentValue","offsetWidth","undefined","close","open","getElementsByClassName","style","transform","remove","moveSlider","action","bind","runWithoutAnimation","triggerEvent","Open","getElementsByTagName","Close","navigateTo","listItem","back","navigate","Backward","destroy","_a","Array","from","querySelectorAll","decorator","forEach","parentElement","removeChild","control","backlink","parentLi","parentsOne","unwrapElement","cssText","ul","target","Navigate","HTMLElement","active","activeElem","display","parentUl","parents","length","_this","anchor","addEventListener","event","targetAnchor","matches","Forward","onTransitionEnd","initKeybindings","initSubmenuVisibility","key","preventDefault","lastActiveSelector","repeat","lastActiveUl","afterAnimation","CustomEvent","dispatchEvent","dir","Back","toString","includes","left","right","transitionElems","transition","offsetHeight","removeProperty","submenu","backLinkTitle","title","textContent","anchorText","addLinkDecorators","innerHTML","titleLi","appendChild","insertBefore","firstChild","backLink","setAttribute","backLinkLi","linkBeforeElem","linkAfterElem","NAMESPACE","btn","className","getAttribute","menu","getElementById","instance","method","arg","window","parent","selector","limit","matched","push","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty","call","r","Symbol","toStringTag","value","menuElement"],"sourceRoot":""}